# lab10z2

Функция `counting_sort` принимает в качестве аргумента ссылку на массив целых чисел и сортирует его с помощью алгоритма подсчета. Вот что происходит в каждой строке:

1. `int max_element = *std::max_element(arr.begin(), arr.end());` - Находит максимальный элемент в массиве.
2. `int min_element = *std::min_element(arr.begin(), arr.end());` - Находит минимальный элемент в массиве.
3. `int range = max_element - min_element + 1;` - Вычисляет диапазон значений в массиве.
4. `std::vector<int> count(range, 0);` - Создает вспомогательный массив `count` размером, равным вычисленному диапазону значений, и инициализирует его нулями.
5. `std::vector<int> output(arr.size());` - Создает массив `output` того же размера, что и исходный массив. Он будет использоваться для хранения отсортированных значений.
6. `for (int i = 0; i < arr.size(); i++) { count[arr[i] - min_element]++; }` - Проходит по исходному массиву и увеличивает значение в массиве `count` на соответствующем индексе.
7. `for (int i = 1; i < count.size(); i++) { count[i] += count[i - 1]; }` - Обновляет каждый элемент массива `count` как сумму его и предыдущего элемента.
8. `for (int i = arr.size() - 1; i >= 0; i--) { output[count[arr[i] - min_element] - 1] = arr[i]; count[arr[i] - min_element]--; }` - Идет с конца исходного массива, помещает каждый элемент в отсортированную позицию в массиве `output` и уменьшает соответствующий счетчик в массиве `count`.
9. `for (int i = 0; i < arr.size(); i++) { arr[i] = output[i]; }` - Копирует отсортированные значения из массива `output` обратно в исходный массив. 

В результате этих операций исходный массив будет отсортирован.

